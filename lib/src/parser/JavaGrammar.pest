// @Note: WHITESPACE and COMMENT are implicit rules and thus can always be matched in between "~"
WHITESPACE = _{ WHITE_SPACE }
COMMENT = _{ ("/*" ~ (!"*/" ~ ANY)* ~ "*/") | ("//" ~ (!"\n" ~ ANY)*)}


Program = {ClassDecl+}

ClassDecl = {"class" ~ Identifier ~ "{" ~ (MethodDecl|FieldDecl)* ~ "}"}

FieldDecl = {JType ~ FieldVarDeclList ~ ";"}

MethodDecl = {JType ~ Identifier ~ "(" ~ ParamDeclList? ~ ")" ~ BlockStmt}

ParamDeclList = {ParamDecl ~ (","~ParamDecl)*}

ParamDecl = {JType ~ Identifier}

FieldVarDeclList = {FieldVarDecl ~ (","~FieldVarDeclList)*}

FieldVarDecl = {Identifier ~ ("="~Expr)?}

JType = {PrimitiveType | Identifier}

PrimitiveType = {"int" | "boolean" | "char" | "String" | "void" | "null"}

//ipmlemented
Identifier ={ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

BlockStmt = {"{" ~ Stmt* ~ "}"}

Stmt = {  WhileStmt | IfElseStmt | IfStmt | ReturnStmt | LocalVarDeclStmt | StmtExpr ~ ";" | BlockStmt }

ReturnStmt = {"return" ~ Expr ~ ";"}

WhileStmt = {"while" ~ "(" ~ Expr ~ ")" ~ Stmt}

// @Question: Is this a correct and easy-to-use definition?
IfElseStmt = {IfStmt ~ "else" ~ Stmt}

IfStmt = {"if" ~ "(" ~ Expr ~ ")" ~ Stmt}

// @Cleanup: Can maybe be unified with FieldVarDecl and AssignExpr?
LocalVarDeclStmt = {JType ~ Identifier ~ ("="~Expr)? ~ ";"}

StmtExpr = {AssignExpr | NewExpr | MethodCallExpr}

AssignExpr = {(InstVarExpr | Identifier) ~ "=" ~ Expr}

NewExpr = {"new" ~ Identifier ~ "(" ~ ParamList? ~ ")"}

MethodCallExpr = {(InstVarExpr | Identifier) ~ "(" ~ ParamList? ~ ")"}

ParamList = {Expr ~ (","~Expr)*}

// @Note we do not support `super` at the moment
Expr = {NonBinaryExpr | Prec3BinExpr}

NonBinaryExpr = { ParanthesizedExpr
		        | UnaryExpr
		        | InstVarExpr
		        | IntLiteral
		        | BoolLiteral
		        | CharLiteral
		        | StrLiteral
				| ThisExpr
		        | JNull
		        | StmtExpr
				| Identifier }

ThisExpr = {"this"}
JNull    = {"null"}

IntLiteral  = {NUMBER+}
BoolLiteral = {"true" | "false"}
CharLiteral = { "'"  ~ (!("'"  | "\\") ~ ANY | EscapedChar) ~ "'"}
StrLiteral  = { "\"" ~ (!("\"" | "\\") ~ ANY | EscapedChar)* ~ "\""}
EscapedChar = { "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    		  | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})}

// @Note We don't support an Expression as the instantiated object
// i.e. something like `someMethodCall().identifier`
InstVarExpr = {(ThisExpr|Identifier) ~ "." ~ Identifier}

ParanthesizedExpr = {"(" ~ Expr ~ ")"}

UnaryExpr = {UnaryOp ~ (InstVarExpr|ParanthesizedExpr|Identifier)}
UnaryOp = {"+" | "-" | "!"}

Prec3BinExpr = {(Prec2BinExpr  ~ Prec3BinOp ~ Prec3BinExpr) | Prec2BinExpr}
Prec2BinExpr = {(Prec1BinExpr  ~ Prec2BinOp ~ Prec2BinExpr) | Prec1BinExpr}
Prec1BinExpr = {(Prec0BinExpr  ~ Prec1BinOp ~ Prec1BinExpr) | Prec0BinExpr}
Prec0BinExpr = {(NonBinaryExpr ~ Prec0BinOp ~ Prec0BinExpr) | NonBinaryExpr}
Prec3BinOp = {"==" | "!=" | "&&" | "||"}
Prec2BinOp = {"<=" | ">=" | "<" | ">"}
Prec1BinOp = {"+" | "-"}
Prec0BinOp = {"*" | "/" | "%"}
