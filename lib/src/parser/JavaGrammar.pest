//! Grammar~doc
ID = {ASCII_ALPHA_UPPER~ASCII_ALPHA+}
Name = {ID~","~ID}
List = {(Name~"\n")+}


IDENTIFIER ={(ASCII_ALPHA|"_")~(ASCII_ALPHANUMERIC|"_")* }

compilationunit = {typedeclarations+ }

typedeclarations = {typedeclaration }

name    ={IDENTIFIER ~("."~IDENTIFIER)*}

typedeclaration  = {classdeclaration }

classdeclaration = {"class"~IDENTIFIER~classbody
                 | modifiers~"class"~IDENTIFIER~classbody}

classbody        = {"{"~"}"
		 | "{"~classbodydeclarations~"}" }

modifiers        ={ modifier+}


classbodydeclarations =  {classbodydeclaration+}

modifier         = {"public"
		 | "protected"
                 | "private"
                 | "static"
                 | "abstract" }

classtype        = {classorinterfacetype}

classbodydeclaration = {classmemberdeclaration
		 | constructordeclaration }

classorinterfacetype = {name}

classmemberdeclaration = {fielddeclaration
		 | methoddeclaration }

constructordeclaration = {constructordeclarator~constructorbody
		 |  modifiers~constructordeclarator~constructorbody }

fielddeclaration = {typeJ~variabledeclarators~";"
 		 | modifiers~typeJ~variabledeclarators~";"}

methoddeclaration = {methodheader~methodbody }

block            = {"{"~"}"
                 		 | "{"~blockstatements~"}" }

constructordeclarator = { IDENTIFIER~"()"
		 |  IDENTIFIER~"("~formalparameterlist~")"  }

constructorbody	 ={ "{"~"}"
		|"{"~explicitconstructorinvocation~"}"
		|"{"~blockstatements~"}"
		|"{"~explicitconstructorinvocation~blockstatements~"}"}

methodheader	 ={ typeJ~methoddeclarator
		 | modifiers~typeJ~methoddeclarator
		 | "void"~methoddeclarator
		 | modifiers~"void"~methoddeclarator }

typeJ             = {primitivetype
		 | referencetype }

variabledeclarators ={ variabledeclarator~(","~variabledeclarator)* }

methodbody       = {block
		 | ";" }

blockstatements  = {blockstatement+}

formalparameterlist = {formalparameter~(","~formalparameter)*}

explicitconstructorinvocation = {"this"~"("~")"~";"
		 | "this"~"("~argumentlist~")"~";"}

classtypelist    ={ classtype~(","~classtype)*}

methoddeclarator ={ IDENTIFIER~"("~")"
		 | IDENTIFIER~"("~formalparameterlist~")"  }

primitivetype    = {"boolen"
		 | numerictype }

referencetype    = {classorinterfacetype }


variabledeclarator ={ variabledeclaratorid
		 | variabledeclaratorid~"="~variableinitializer }

blockstatement	 ={ localvariabledeclarationstatement
		 | statement  }

formalparameter  = {typeJ~variabledeclaratorid }

argumentlist     = {expression~(","~expression)*}

numerictype      ={ integraltype }

variabledeclaratorid = {IDENTIFIER }

variableinitializer  ={ expression }

localvariabledeclarationstatement = {localvariabledeclaration~";"  }

statement        = {statementwithouttrailingsubstatement
		 | ifthenstatement
		 | ifthenelsestatement
		 | whilestatement }


expression       = {assignmentexpression }

integraltype     ={ "int"
                 | "char" }

localvariabledeclaration ={ typeJ~variabledeclarators }

statementwithouttrailingsubstatement = {block
		 | emptystatement
		 | expressionstatement
		 | returnstatement }

ifthenstatement  ={ "if"~"("~expression~")"~statement }

ifthenelsestatement = {"if"~"("~expression~")"~statementnoshortif~"else"~statement  }

whilestatement   = {"while"~"("~expression~")"~statement }

assignmentexpression = {conditionalexpression
		 |  assignment}

emptystatement	 =  {";"  }

expressionstatement ={ statementexpression~";" }

returnstatement  ={ "return"~";"
		 | "return"~expression~";" }

statementnoshortif = {statementwithouttrailingsubstatement
		 | ifthenelsestatementnoshortif
		 | whilestatementnoshortif }

conditionalexpression = {conditionalorexpression
		 | conditionalorexpression~"?"~expression~":"~conditionalexpression }

assignment       ={lefthandside~assignmentoperator~assignmentexpression }


statementexpression = {assignment
		 | preincrementexpression
		 | predecrementexpression
		 | postfixexpression
		 | methodinvocation
		 | classinstancecreationexpression }

ifthenelsestatementnoshortif ={"if"~"("~expression~")"~statementnoshortif~"else"~statementnoshortif  }

whilestatementnoshortif = {"while"~"("~expression~")"~statementnoshortif }

conditionalorexpression ={ conditionalandexpression~("||"~conditionalandexpression)+}

lefthandside     = {name }

assignmentoperator = {"="
		 | "*="
		 | "/="
		 | "%="
		 | "+="
		 | "-="
		 | "<<="
		 | ">>="
		 | ">>>="
		 | "&="
		 | "^="
		 | "|="}

preincrementexpression = {"++"~unaryexpression }

predecrementexpression = {"--"~unaryexpression }

methodinvocation= {
(name|fieldaccess)~"("~argumentlist?~")" }
/*
methodinvocation = {name~"("~")"
		 | name~"("~argumentlist~")"
		 | primary~"."~IDENTIFIER~"("~")"
		 | primary~"."~IDENTIFIER~"("~argumentlist~")"  }
*/

classinstancecreationexpression ={ "new"~classtype~"("~")"
                 | "new"~classtype~"("~argumentlist~")"  }

conditionalandexpression ={ inclusiveorexpression }

//fieldaccess      = {primary~"."~IDENTIFIER }

fieldaccess ={(literal
		 | "this"
		 | "("~expression~")"
         | classinstancecreationexpression)~"."~idorfield
}
idorfield={fieldaccess|IDENTIFIER}

unaryexpression	 = {preincrementexpression
		 | predecrementexpression
		 | "+"~unaryexpression
		 | "-"~unaryexpression
		 | unaryexpressionnotplusminus }

postfixexpression = {(primary
		 | name)~("++"|"--" )}

inclusiveorexpression = {exclusiveorexpression~("|"~exclusiveorexpression)*}

primary = {literal
		 | "this"
		 | "("~expression~")"
                 | classinstancecreationexpression
		 | fieldaccess
		 | methodinvocation }

unaryexpressionnotplusminus = {postfixexpression
	         | "~"~unaryexpression
		 | "!"~unaryexpression                          // EXCLMARK wurde mit "!" replaced
		 | castexpression}

exclusiveorexpression ={ andexpression~("^"~andexpression)*}


literal		 = {INTLITERAL
		 | BOOLLITERAL
		 | CHARLITERAL
		 | STRINGLITERAL
		 | "null" }

CHARLITERAL = { "'"~ASCII~"'" }

STRINGLITERAL = { "\""~ASCII*~"\"" }

BOOLLITERAL = {"true"|"false"}
INTLITERAL = {NUMBER+
|
            NUMBER+~"."~NUMBER+
}


castexpression	 ={ "("~primitivetype~")"~unaryexpression
 		 | "("~expression~")"~unaryexpressionnotplusminus}

andexpression    = {equalityexpression~("&"~equalityexpression )*}

equalityexpression = {relationalexpression~(("!=" |"==")~relationalexpression)*}


relationalexpression = {
shiftexpression~"instanceof"~referencetype
|shiftexpression~(("<"|">"|"<="|">=")~shiftexpression)*
 }

shiftexpression	 = {additiveexpression }

additiveexpression ={ multiplicativeexpression~(("+"|"-")~multiplicativeexpression)*}

multiplicativeexpression ={ unaryexpression~(("*"|"/"|"%")~unaryexpression)*}

