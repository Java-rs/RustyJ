//! Grammar~doc
ID = {ASCII_ALPHA_UPPER~ASCII_ALPHA+}
Name = {ID~","~ID}
List = {(Name~"\n")+}


IDENTIFIER ={(ASCII_ALPHA|"_")~(ASCII_ALPHANUMERIC|"_")+ }

compilationunit = {typedeclarations }

typedeclarations = {typedeclaration  | typedeclarations~typedeclaration }

name    ={ qualifiedname 
		 | simplename }

typedeclaration  = {classdeclaration }

qualifiedname    = {name~"."~IDENTIFIER }

simplename       = {IDENTIFIER }

classdeclaration = {"class"~IDENTIFIER~classbody
                 | modifiers~"class"~IDENTIFIER~classbody}

classbody        = {"{"~"}"
		 | "{"~classbodydeclarations~"}" }

modifiers        ={ modifier
		 | modifiers~modifier	}

classbodydeclarations =  {classbodydeclaration
		 | classbodydeclarations~classbodydeclaration}

modifier         = {"public"
		 | "protected"
                 | "private"
                 | "static"
                 | "abstract" }

classtype        = {classorinterfacetype}

classbodydeclaration = {classmemberdeclaration 
		 | constructordeclaration }

classorinterfacetype = {name}

classmemberdeclaration = {fielddeclaration 
		 | methoddeclaration }

constructordeclaration = {constructordeclarator~constructorbody 
		 |  modifiers~constructordeclarator~constructorbody }

fielddeclaration = {typeJ~variabledeclarators~";" 
 		 | modifiers~typeJ~variabledeclarators~";"} 

methoddeclaration = {methodheader~methodbody }

block            = {"{"~"}"
                 		 | "{"~blockstatements~"}" }

constructordeclarator = { simplename~"()"  
		 |  simplename~"("~formalparameterlist~")"  }

constructorbody	 ={ "{"~"}"
		|"{"~explicitconstructorinvocation~"}"
		|"{"~blockstatements~"}"
		|"{"~explicitconstructorinvocation~blockstatements~"}"}

methodheader	 ={ typeJ~methoddeclarator
		 | modifiers~typeJ~methoddeclarator
		 | "void"~methoddeclarator
		 | modifiers~"void"~methoddeclarator }

typeJ             = {primitivetype 
		 | referencetype }

variabledeclarators ={ variabledeclarator 
		 | variabledeclarators~","~variabledeclarator }

methodbody       = {block 
		 | ";" }

blockstatements  = {blockstatement 
		 | blockstatements~blockstatement }

formalparameterlist = {formalparameter 
		 | formalparameterlist~","~formalparameter}

explicitconstructorinvocation = {"this"~"("~")"~";"  
		 | "this"~"("~argumentlist~")"~";"}

classtypelist    ={ classtype 
		 | classtypelist~","~classtype }

methoddeclarator ={ IDENTIFIER~"("~")"  
		 | IDENTIFIER~"("~formalparameterlist~")"  }

primitivetype    = {BOOLEAN
		 | numerictype }

referencetype    = {classorinterfacetype }


variabledeclarator ={ variabledeclaratorid 
		 | variabledeclaratorid~"="~variableinitializer }

blockstatement	 ={ localvariabledeclarationstatement 
		 | statement  }

formalparameter  = {typeJ~variabledeclaratorid }

argumentlist     = {expression 
		 | argumentlist~","~expression }

numerictype      ={ integraltype }

variabledeclaratorid = {IDENTIFIER }

variableinitializer  ={ expression }

localvariabledeclarationstatement = {localvariabledeclaration~";"  }

statement        = {statementwithouttrailingsubstatement
		 | ifthenstatement 
		 | ifthenelsestatement 
		 | whilestatement }


expression       = {assignmentexpression }

integraltype     ={ "int"
                 | "char" }

localvariabledeclaration ={ typeJ~variabledeclarators }

statementwithouttrailingsubstatement = {block 
		 | emptystatement 
		 | expressionstatement 
		 | returnstatement }

ifthenstatement  ={ "if"~"("~expression~")"~statement }

ifthenelsestatement = {"if"~"("~expression~")"~statementnoshortif~"else"~statement  }

whilestatement   = {"while"~"("~expression~")"~statement }

assignmentexpression = {conditionalexpression 
		 |  assignment}

emptystatement	 =  {";"  }

expressionstatement ={ statementexpression~";" }

returnstatement  ={ "return"~";"  
		 | "return"~expression~";" }

statementnoshortif = {statementwithouttrailingsubstatement
		 | ifthenelsestatementnoshortif
		 | whilestatementnoshortif }

conditionalexpression = {conditionalorexpression
		 | conditionalorexpression~"?"~expression~":"~conditionalexpression }

assignment       ={lefthandside~assignmentoperator~assignmentexpression }


statementexpression = {assignment
		 | preincrementexpression
		 | predecrementexpression
		 | postincrementexpression
		 | postdecrementexpression
		 | methodinvocation
		 | classinstancecreationexpression }

ifthenelsestatementnoshortif ={"if"~"("~expression~")"~statementnoshortif~"else"~statementnoshortif  }

whilestatementnoshortif = {"while"~"("~expression~")"~statementnoshortif }

conditionalorexpression ={ conditionalandexpression
		 | conditionalorexpression~"||"~conditionalandexpression}

lefthandside     = {name }

assignmentoperator = {"="
		 | "*="
		 | "/="
		 | "%="
		 | "+="
		 | "-="
		 | "<<="
		 | ">>="
		 | ">>>="
		 | "&="
		 | "^="
		 | "|="}

preincrementexpression = {"++"~unaryexpression }

predecrementexpression = {"--"~unaryexpression }

postincrementexpression = {postfixexpression~"++" }

postdecrementexpression = {postfixexpression~"--" }

methodinvocation = {name~"("~")"  
		 | name~"("~argumentlist~")" 
		 | primary~"."~IDENTIFIER~"("~")"  
		 | primary~"."~IDENTIFIER~"("~argumentlist~")"  }

classinstancecreationexpression ={ "new"~classtype~"("~")"
                 | "new"~classtype~"("~argumentlist~")"  }

conditionalandexpression ={ inclusiveorexpression }

fieldaccess      = {primary~"."~IDENTIFIER }

unaryexpression	 = {preincrementexpression
		 | predecrementexpression
		 | "+"~unaryexpression
		 | "-"~unaryexpression
		 | unaryexpressionnotplusminus }

postfixexpression = {primary
		 | name
		 | postincrementexpression
		 | postdecrementexpression}

primary		 = {primarynonewarray }

inclusiveorexpression = {exclusiveorexpression
		 | inclusiveorexpression~"|"~exclusiveorexpression }

primarynonewarray = {literal
		 | "this"
		 | "("~expression~")"
                 | classinstancecreationexpression
		 | fieldaccess
		 | methodinvocation }

unaryexpressionnotplusminus = {postfixexpression
	         | "~"~unaryexpression
		 | "!"~unaryexpression                          // EXCLMARK wurde mit "!" replaced
		 | castexpression}

exclusiveorexpression ={ andexpression
		 | exclusiveorexpression~"^"~andexpression }

literal		 = {INTLITERAL
		 | BOOLLITERAL
		 | CHARLITERAL
		 | STRINGLITERAL
		 | JNULL }

CHARLITERAL = { "'"~ASCII~"'" }

STRINGLITERAL = { "\""~ASCII*~"\"" }

BOOLLITERAL = {"true"|"false"}
INTLITERAL = {NUMBER+
|
            NUMBER+~"."~NUMBER+
}


castexpression	 ={ "("~primitivetype~")"~unaryexpression
 		 | "("~expression~")"~unaryexpressionnotplusminus}

andexpression    = {equalityexpression
		 | andexpression~"&"~equalityexpression }

equalityexpression = {relationalexpression
		 | equalityexpression~"=="~relationalexpression
		 | equalityexpression~"!="~relationalexpression }

relationalexpression = {shiftexpression
		 | relationalexpression~"<"~shiftexpression
		 | relationalexpression~">"~shiftexpression
		 | relationalexpression~"<="~shiftexpression
		 | relationalexpression~">="~shiftexpression
		 | relationalexpression~"instanceof"~referencetype }

shiftexpression	 = {additiveexpression }

additiveexpression ={ multiplicativeexpression 
		 | additiveexpression~"+"~multiplicativeexpression 
		 | additiveexpression~"-"~multiplicativeexpression }

multiplicativeexpression ={ unaryexpression
		 | multiplicativeexpression~"*"~unaryexpression
		 | multiplicativeexpression~"/"~unaryexpression
		 | multiplicativeexpression~"%"~unaryexpression }


